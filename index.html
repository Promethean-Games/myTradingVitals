<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>myTradingVitals v2.5 â€“ Enhanced</title>
  <style>
    :root {
      --bg: #fafafa;
      --fg: #111;
      --panel: #fff;
      --accent: #d11111;
    }
    body.dark-mode {
      --bg: #111;
      --fg: #f5f5f5;
      --panel: #222;
      --accent: #e63946;
    }
    body {
      font-family: system-ui, sans-serif;
      background: var(--bg);
      color: var(--fg);
      margin: 0;
      padding: 0;
    }
    header {
      background: var(--accent);
      color: #fff;
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 { font-size: 1.2rem; margin: 0; }
    .container { padding: 1rem; }
    .panel {
      background: var(--panel);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.25rem;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    th, td {
      border-bottom: 1px solid #ccc;
      padding: 0.4rem 0.6rem;
      text-align: left;
    }
    th { background: var(--accent); color: white; }
    .dotplot-toolbar {
      margin-bottom: 0.75rem;
      font-size: 0.9rem;
    }
    .calendar-icon {
      font-size: 1.1rem;
      vertical-align: middle;
    }
    body.dark-mode .calendar-icon { color: white; }
    .toggle-theme {
      background: none;
      border: 1px solid #fff;
      border-radius: 6px;
      color: #fff;
      padding: 0.25rem 0.75rem;
      cursor: pointer;
    }
    canvas { width: 100%; height: 300px; }
  </style>
</head>
<body>
  <header>
    <h1>myTradingVitals Dashboard</h1>
    <button id="themeToggle" class="toggle-theme">Dark Mode</button>
  </header>

  <div class="container">
    <div class="panel">
      <h2><span class="calendar-icon">ðŸ“…</span> Import Transactions</h2>
      <input type="file" id="csvInput" accept=".csv" />
    </div>

    <div class="panel">
      <h2>Best/Worst Dot Plot</h2>
      <div class="dotplot-toolbar">
        Show:
        <label><input type="radio" name="dotFilter" value="all" checked> All</label>
        <label><input type="radio" name="dotFilter" value="call"> Calls</label>
        <label><input type="radio" name="dotFilter" value="put"> Puts</label>
      </div>
      <canvas id="bestWorstDotPlot"></canvas>
    </div>

    <div class="panel">
      <h2>Trade History</h2>
      <table id="tradeHistoryTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Ticker</th>
            <th>Dir</th>
            <th>Size</th>
            <th>Entry</th>
            <th>Exit</th>
            <th>PNL</th>
            <th>DTE</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // ====== THEME TOGGLE ======
    const themeBtn = document.getElementById('themeToggle');
    themeBtn.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      themeBtn.textContent = document.body.classList.contains('dark-mode')
        ? 'Light Mode' : 'Dark Mode';
      renderDotPlot(currentFilteredTrades);
    });

    // ====== UTILITIES ======
    function calculateDTE(openDateStr, expirationStr) {
      if (!openDateStr || !expirationStr) return '';
      const open = new Date(openDateStr);
      const exp  = new Date(expirationStr);
      const diff = exp - open;
      return isNaN(diff) ? '' : Math.round(diff / (1000 * 60 * 60 * 24));
    }

    function buildContractKey(tx) {
      return [tx.ticker || '', tx.expiration || '', tx.strike || '', tx.optionType || ''].join('|');
    }

    // ====== CSV PARSER ======
    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim() !== '');
      const headers = lines[0].split(',').map(h => h.trim());
      return lines.slice(1).map(line => {
        const values = line.split(',');
        const row = {};
        headers.forEach((h,i) => row[h] = values[i]);
        return row;
      });
    }

    // ====== TRADE PAIRING ======
    function pairTransactions(txs) {
      const normalized = txs.map(tx => ({
        date: tx.date,
        ticker: tx.ticker,
        direction: tx.direction,
        size: Number(tx.size),
        price: Number(tx.entry || tx.exit || tx.price || 0),
        amount: Number(tx.pnl || tx.amount || 0),
        expiration: tx.expiration || '',
        strike: tx.strike || '',
        optionType: (tx.optionType || '').toUpperCase() || inferOptionType(tx.notes || '')
      })).sort((a,b) => new Date(a.date) - new Date(b.date));

      const openByKey = {};
      const trades = [];

      normalized.forEach(tx => {
        const key = buildContractKey(tx);
        const dir = (tx.direction || '').toUpperCase();
        const isBuy = dir.includes('BUY TO OPEN');
        const isSell = dir.includes('SELL TO CLOSE');

        if (isBuy) {
          if (!openByKey[key]) {
            openByKey[key] = { ...tx, entryValue: 0, exitValue: 0, pnl: 0, legs: [], size: 0 };
          }
          const t = openByKey[key];
          t.entryValue += tx.price * tx.size;
          t.size += tx.size;
          t.pnl += tx.amount;
          t.legs.push(tx);
        }

        if (isSell) {
          const t = openByKey[key];
          if (!t) return;
          t.exitValue += tx.price * tx.size;
          t.pnl += tx.amount;
          t.closeDate = tx.date;
          t.legs.push(tx);
          t.size -= tx.size;
          if (t.size <= 0) {
            const buyLegs = t.legs.filter(l => (l.direction || '').toUpperCase().includes('BUY'));
            const contracts = buyLegs.reduce((sum, l) => sum + l.size, 0);
            const entryPrice = t.entryValue / (contracts || 1);
            const exitPrice  = t.exitValue / (contracts || 1);
            trades.push({
              ticker: t.ticker,
              expiration: t.expiration,
              strike: t.strike,
              optionType: t.optionType,
              openDate: t.date,
              closeDate: t.closeDate,
              entryPrice,
              exitPrice,
              pnl: t.pnl,
              dte: calculateDTE(t.date, t.expiration)
            });
            delete openByKey[key];
          }
        }
      });
      return trades;
    }

    function inferOptionType(text) {
      const s = text.toUpperCase();
      if (s.includes('CALL')) return 'C';
      if (s.includes('PUT')) return 'P';
      return '';
    }

    // ====== DOT PLOT ======
    let bestWorstChart = null;
    let currentFilteredTrades = [];

    function renderDotPlot(trades) {
      currentFilteredTrades = trades;
      const ctx = document.getElementById('bestWorstDotPlot').getContext('2d');
      const data = trades.map(t => ({
        x: new Date(t.closeDate),
        y: t.pnl,
        label: `${t.ticker} ${t.optionType} ${t.strike} (${t.dte} DTE)`
      }));

      const isDark = document.body.classList.contains('dark-mode');
      const pointColor = isDark ? '#66c2ff' : '#0066cc';

      if (bestWorstChart) bestWorstChart.destroy();
      bestWorstChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Trades',
            data,
            backgroundColor: pointColor
          }]
        },
        options: {
          scales: {
            x: { type: 'time', time: { unit: 'day' }, title: { display: true, text: 'Date' } },
            y: { title: { display: true, text: 'PNL ($)' } }
          },
          plugins: {
            tooltip: {
              callbacks: {
                label: ctx => ctx.raw.label + ' | ' + ctx.raw.y.toFixed(2)
              }
            }
          }
        }
      });
    }

    // ====== TRADE HISTORY ======
    function renderTradeHistory(trades) {
      const tbody = document.querySelector('#tradeHistoryTable tbody');
      tbody.innerHTML = '';
      trades.forEach(tr => {
        const trEl = document.createElement('tr');
        [tr.openDate, tr.ticker, tr.optionType, 1, 
         tr.entryPrice.toFixed(2), tr.exitPrice.toFixed(2),
         tr.pnl.toFixed(2), tr.dte]
         .forEach(val => {
          const td = document.createElement('td');
          td.textContent = val;
          trEl.appendChild(td);
        });
        tbody.appendChild(trEl);
      });
    }

    // ====== DOT FILTER ======
    document.addEventListener('change', e => {
      if (e.target.name === 'dotFilter') {
        const val = e.target.value;
        let filtered = allTrades;
        if (val === 'call') filtered = allTrades.filter(t => t.optionType === 'C');
        if (val === 'put') filtered = allTrades.filter(t => t.optionType === 'P');
        renderDotPlot(filtered);
      }
    });

    // ====== FILE IMPORT ======
    let allTrades = [];

    document.getElementById('csvInput').addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        const text = ev.target.result;
        const rows = parseCSV(text);
        allTrades = pairTransactions(rows);
        renderDotPlot(allTrades);
        renderTradeHistory(allTrades);
      };
      reader.readAsText(file);
    });
  </script>
</body>
</html>
